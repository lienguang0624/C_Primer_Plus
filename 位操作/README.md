# 位运算符

&emsp;&emsp;整数类型的位模式由一队按位置从右到左编号的位组成，位置编号从 0 开始，这是最低有效位（least significant bit）。例如，考虑字符值'*'，它的 ASCII 编码为 42，相当于二进制的 101010：

&emsp;&emsp;位模式　0　0　1　0　1　0　1　0


&emsp;&emsp;位位置　7　6　5　4　3　2　1　0

## 布尔位运算符
表 1 中列举的运算符可以对操作数的每个位进行布尔运算。这种二元运算符把两个不同操作数内相同位置的位关联起来。被设定的位（也就是值为 1 的位）被解释为 true，被清除的位（也就是值为 0 的位）被解释为 false。


& ：位 AND	x&y 	
 
 &emsp;&emsp;如果 x 和 y 都为 1，则得到 1；如果 x 或 y 任何一个为 0，或都为0，则得到 0

| ：位 OR	 x|y 	 

 &emsp;&emsp;如果 x 或 y 为 1，或都为 1，则得到 1；如果 x 和 y 都为 0，则得到 0

^ ：位 XOR	 x^y 	
 
 &emsp;&emsp;如果 x 或 y 的值不同，则得到 1；如果两个值相同，则得到 0
    
    
~ ：位 NOT（I的补码）	 ~x 	

&emsp;&emsp;如果 x 为 0，则得到 1，如果 x 是 1，则得到 0

案例：
```c
    int a  = 6; //位模式为00000110
    int b = 11; //位模式为00001011
    int c = 0;

    c = a&b;
    printf("a&b:%d\n",c);//a&b:2 位模式为00000010

    c = a|b;
    printf("a&b:%d\n",c);//a&b:15 位模式为00001111

    c = a^b;
    printf("a^b:%d\n",c);//a^b:13 位模式为00001101

    c = ~a;
    printf("~a:%d\n",c);//~a:-7 位模式为11111001
```

## 移位运算符
移位运算符将左操作数的位模式移动数个位置，至于移动几个位置，由右操作数指定。它们如下列举。
```
<<	向左移位	x<<y	x 的每个位向左移动 y 个位
>>	向右移位	x>>y	x 的每个位向右移动 y 个位
```
```c
    unsigned long n = 0xB,     // 位模式： 0 ... 0 0 0 1 0 1 1
    result = 0;
    result = n << 2;          //              0 ... 0 1 0 1 1 0 0
    printf("result:%d\n",result);
    result = n >> 2;          //              0 ... 0 0 0 0 0 1 0
    printf("result:%d\n",result);
```